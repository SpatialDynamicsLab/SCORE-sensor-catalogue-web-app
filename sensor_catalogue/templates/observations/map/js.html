<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.0"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-gauge@0.2.1/dist/chartjs-gauge.min.js"></script>

<script>
    // Display loading GIF
    let charts = {};
    let backToTopBtn = document.getElementById("backToTopBtn");
    var sensor = document.getElementById('sensor');
    var datasensor = document.getElementById('datasensor');
    var chartsarea = document.getElementById('chartscontainer');
    var dropdownarea = document.getElementById('dropdown');
    var cLoading = document.getElementById('chart-loading');
    var chartboxes = document.querySelectorAll('.chartbox');
    const cardinalPoints = [
        { label: "N", min: 348.75, max: 360 },
        { label: "N", min: 0, max: 11.25 },
        { label: "NNE", min: 11.25, max: 33.75 },
        { label: "NE", min: 33.75, max: 56.25 },
        { label: "ENE", min: 56.25, max: 78.75 },
        { label: "E", min: 78.75, max: 101.25 },
        { label: "ESE", min: 101.25, max: 123.75 },
        { label: "SE", min: 123.75, max: 146.25 },
        { label: "SSE", min: 146.25, max: 168.75 },
        { label: "S", min: 168.75, max: 191.25 },
        { label: "SSW", min: 191.25, max: 213.75 },
        { label: "SW", min: 213.75, max: 236.25 },
        { label: "WSW", min: 236.25, max: 258.75 },
        { label: "W", min: 258.75, max: 281.25 },
        { label: "WNW", min: 281.25, max: 303.75 },
        { label: "NW", min: 303.75, max: 326.25 },
        { label: "NNW", min: 326.25, max: 348.75 }
    ];


    document.getElementById('loading-gif').style.display = 'block';
    var smartCitizenMarkers = L.markerClusterGroup({
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true
    });
    var wuMarkers = L.markerClusterGroup({
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true
    });

    var baseLayers = {};
    var overlayLayers = {
        "Smart Citizen Devices": smartCitizenMarkers,
        "WU Personal Weather Stations": wuMarkers
    };

    var map = L.map('map').setView([53.3105866, -6.2359141], 13);
    // Load and display tile layer on the map
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; CARTO © OpenStreetMap contributors',
        maxZoom: 18
    }).addTo(map);

    window.onscroll = function () {
        scrollFunction();
    };




    function getCardinalDirection(degree) {
        for (let i = 0; i < cardinalPoints.length; i++) {
            const point = cardinalPoints[i];
            if (degree >= point.min && degree < point.max) {
                return point.label;
            }
        }
        return "Invalid degree";
    }

   
    function scrollFunction() {
        if (document.body.scrollTop > 50 || document.documentElement.scrollTop > 50) {
            backToTopBtn.style.display = "block";
        } else {
            backToTopBtn.style.display = "none";
        }
    }
    // When the user clicks on the button, scroll to the top of the document
    backToTopBtn.addEventListener('click', function () {
        document.body.scrollTop = 0; // For Safari
        document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    });


    let formattedPreviousDate, formattedCurrentDate;

    // Function to format date
    function formatDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are zero-based
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    function updateDateRange(days) {
        const currentDate = new Date();
        const previousDate = new Date(currentDate);
        previousDate.setDate(currentDate.getDate() - days);

        formattedCurrentDate = formatDate(currentDate);
        formattedPreviousDate = formatDate(previousDate);


    }

    // Initial date range (last 7 days)
    updateDateRange(1);



    async function fetchData(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Network response was not ok ' + response.statusText);
        }
        return await response.json();
    }
    // L.control.layers(baseLayers, overlayLayers).addTo(map);


    function displayDeviceDetails(feature) {

        properties = feature.properties
        var detailsHtml = '<h3 style="color:#004680"><b>' + properties.name + '</b></h3>';
        detailsHtml += '<p>' + properties.description + '<br><br><strong>Last Observation: '
            + properties.last_reading_at +
            '</strong><br><small>Platform provider: ' +
            '<a href="' + properties.platform_provider.url + '" className="ml-2" target="_blank"> ' +
            properties.platform_provider.name + '</a></small></p>'

        // Horizontal table with one row for CCLL Tags, System Tags, and Owner
        detailsHtml += '<table class="table table-sm table-responsive-sm" >';
        detailsHtml += '<tr>';
        detailsHtml += '<th>CCLL Tags:</th>';
        detailsHtml += '<td>' + properties.user_tags.join(", ") + '</td>';
        detailsHtml += '<th>System Tags:</th>';
        detailsHtml += '<td>' + properties.system_tags.join(", ") + '</td>';
        detailsHtml += '<th>Owner:</th>';
        detailsHtml += '<td>' + properties.owner + '</td>';
        // detailsHtml += '<th>Time series:</th>';
        // detailsHtml += '<td>' + ' <a href="https://dashboard.smartcitizen.me/?id='
        //     + feature.id + '" class="ml-2" target="_blank">Open</a></td>';
        detailsHtml += '</tr>';
        detailsHtml += '</table>';
        // Observations table without 'Added At' column
        detailsHtml += '<table class="table table-sm table-bordered table-hover table-responsive-md">' +
            '<thead class="thead-light">' +
            '<tr><th>Sensor</th><th>Measurement</th><th>Value</th><th>Unit</th></tr></thead><tbody>';
        properties.observations.forEach(function (obs) {
            detailsHtml += '<tr><td>' + obs.sensor_name + '</td><td>' + obs.measurement_name +
                '</td><td>' + obs.value + '</td><td>' + obs.unit + '</td></tr>';
        });
        detailsHtml += '</tbody></table>';

        $('#device-details').html(detailsHtml);

        sensor.style.display = 'none';
        chartsarea.style.display = 'none';
        dropdownarea.style.display = 'none';
        datasensor.style.display = 'none';

    }

    function forEachFeature(feature, layer) {
        layer.on('click', function (e) {
            displayDeviceDetails(feature);
        });
    }

    function displayWUDetails(feature) {
        var properties = feature.properties;
        var observations = properties.observations;
        loadEachWuStationObservation(properties.name);
        sensor.textContent = properties.name;
        var detailsHtml = `
                
            <div class="slider-container">
            <button class="slide-button left" onclick="slideLeft()">&#10094;</button>
               <div class="observations-container">
           
            `;

        for (var key in observations) {
            if (observations.hasOwnProperty(key) && key !== 'id' && key !== 'recorded_at' && key !== 'station_id' && key !== 'station_name') {
                detailsHtml += `
            <a href=#${key} style="border-right: 1px solid #ddd">
                <div class="observation-item">
                    <div class="obsTop">
                    <span class="value">${observations[key].value}</span>
                    <p class="unit">${observations[key].unit}</p>
                    </div>
                    
                   
                    <span class="measurement">${key.replace(/_/g, ' ').toUpperCase()}</span>
                </div>
                </a>
            `;

            }
        }
        detailsHtml += `
        	
            </div>
            <button class="slide-button right" onclick="slideRight()">&#10095;</button>
           </div>
           <div class="deviceInfo"> 
            
            <p>Sensor ID: <strong>${properties.name}</strong></p>
            <p><strong>Last observation: </strong>${properties.observations.recorded_at}</p>

            <p><small>Platform provider: <a href="${properties.platform_provider.url}" class="ml-2" target="_blank"> ${properties.platform_provider.name}</a></small></p>    
            
            </div>
        
    `;



        document.getElementById('device-details').innerHTML = detailsHtml;

        // heatIndexMeter(temparature,humidity,heatIndex);


    }
    function slideLeft() {
        const container = document.querySelector('.observations-container');
        container.scrollBy({ left: -400, behavior: 'smooth' });
    }

    function slideRight() {
        const container = document.querySelector('.observations-container');
        container.scrollBy({ left: 400, behavior: 'smooth' });
    }




    var sampleSize = 1;

    // Function to update sampleSize based on screen size
    function updateSampleSize() {
        var isMobile = window.matchMedia("(max-width: 600px)").matches;
        if (document.getElementById('timeRange').value === 'month') {
            sampleSize = isMobile ? 100 : 50;

        }
        else if (document.getElementById('timeRange').value === 'week') {
            sampleSize = isMobile ? 30 : 10;

        }
        else if (document.getElementById('timeRange').value === 'day') {
            sampleSize = isMobile ? 10 : 5;
        }



        console.log('Sample Size:', sampleSize); // For debugging purposes
    }

    // Update sample size and chart data based on screen size
    function onResize() {
        updateSampleSize();
        if (charts['temp']) {
            loadEachWuStationObservation(sensor.textContent);
        }
    }
    // Add event listener for screen size changes
    window.matchMedia("(max-width: 600px)").addListener(onResize);

    updateSampleSize();



    // Handle time range selection
    function onTimeRangeChange() {
        const timeRange = document.getElementById('timeRange').value;
        if (timeRange === 'week') {
            updateDateRange(7);
        } else if (timeRange === 'month') {
            updateDateRange(30);
        } else if (timeRange == 'day') {
            updateDateRange(1);
        }
        updateSampleSize();
        if (sensor.textContent) {
            loadEachWuStationObservation(sensor.textContent);
        }
    }

    async function loadEachWuStationObservation(stationName) {
        try {
            cLoading.style.display = 'unset';
            const data = await fetchData(`https://environmental-data-ie.spatialdynamicslab.xyz/api/v1/weather-underground/pws/observations/?station_name=${stationName}&start_date=${formattedPreviousDate}&end_date=${formattedCurrentDate}&limit=10000`);

            if (!data.results || data.results.length === 0) {
                console.log('No data available for this station.');
                cLoading.style.display = 'none';
                return;

            }
            sensor.style.display = 'inline';
            datasensor.style.display = 'inline';
            chartsarea.style.display = 'block';
            dropdownarea.style.display = 'block';


            const fields = [
                { key: 'temp', label: 'Temperature (°C)', unit: '°C', transform: value => value, yMin: null, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'atmospheric_pressure', label: 'Atmospheric Pressure (KPa)', unit: 'KPa', transform: value => value / 10, yMin: null, yMax: null, canvasId: 'atmospheric_pressure', chartType: 'line' },
                { key: 'heat_index', label: 'Heat Index (°C)', unit: '°C', transform: value => value, yMin: null, yMax: null, canvasId: 'heat_index', chartType: 'line' },
                { key: 'dew_point', label: 'Dew Point (°C)', unit: '°C', transform: value => value, yMin: null, yMax: null, canvasId: 'dew_point', chartType: 'line' },
                { key: 'relative_humidity', label: 'Relative Humidity (%)', unit: '%', transform: value => value, yMin: null, yMax: null, canvasId: 'relative_humidity', chartType: 'line' },
                { key: 'wind_chill', label: 'Wind Chill (°C)', unit: '°C', transform: value => value, yMin: null, yMax: null, canvasId: 'wind_chill', chartType: 'line' },
                { key: 'solar_radiation', label: 'Solar Radiation (W/m²)', unit: 'W/m²', transform: value => value, yMin: null, yMax: null, canvasId: 'solar_radiation', chartType: 'line' },
                { key: 'wind_speed', label: 'Wind Speed (Km/h)', unit: 'km/h', transform: value => value, yMin: null, yMax: null, canvasId: 'wind_speed', chartType: 'line' },
                { key: 'wind_gust', label: 'Wind Gust (Km/h)', unit: 'km/h', transform: value => value, yMin: null, yMax: null, canvasId: 'wind_gust', chartType: 'line' },
                { key: 'wind_direction', label: 'Wind Direction (Deg)', unit: 'Deg', transform: value => value, yMin: 0, yMax: 360, canvasId: 'wind_direction', chartType: 'line' },
                { key: 'precipitation_rate', label: 'Precipitation Rate (mm/h)', unit: 'mm/h', transform: value => value, yMin: 0, yMax: null, canvasId: 'precipitation_rate', chartType: 'line' },
                { key: 'precipitation_total', label: 'Precipitation total (mm)', unit: 'mm', transform: value => value, yMin: null, yMax: null, canvasId: 'precipitation_total', chartType: 'line' },
                { key: 'uv', label: 'UV (UV index)', unit: 'UV index', transform: value => value, yMin: null, yMax: null, canvasId: 'uv', chartType: 'line' },
            ];
            const labels = data.results.map(observation => new Date(observation.recorded_at)).reverse();

            fields.forEach(field => {
                const hasValidData = data.results.some(observation => observation[field.key] !== undefined && observation[field.key] !== null);
                const values = hasValidData
                    ? data.results.map(observation => observation[field.key] !== undefined && observation[field.key] !== null ? field.transform(observation[field.key].value) : null).reverse()
                    : null;

                const sampledLabels = labels.filter((_, index) => index % sampleSize === 0);
                const sampledValues = values ? values.filter((_, index) => index % sampleSize === 0) : null;
                cLoading.style.display = 'none';
                let meandisplay = true;
                let maxdisplay = true;
                let directionLabels;
                if (field.canvasId == 'wind_direction') {
                    meandisplay = false;
                    maxdisplay = false;
                    if(sampledValues){

                    
                    const validSampledValues = sampledValues.filter(value => value !== null && value !== undefined);
                    directionLabels = validSampledValues.map(value => getCardinalDirection(value));

                    const directionCounts = {};
                    directionLabels.forEach(direction => {
                        directionCounts[direction] = (directionCounts[direction] || 0) + 1;
                    });
                    const windDirectionData = Object.keys(directionCounts).map(direction => ({
                        direction,
                        frequency: directionCounts[direction]
                    }));

                    

                }
                windChart(directionLabels, sampledLabels, field.canvasId, `${field.label}`)


                } else {
                    createChart(field.canvasId, field.label, sampledLabels, sampledValues, `${field.label}`, field.yMin, field.yMax, field.chartType, meandisplay, maxdisplay);
                }

                chartboxes.forEach(function (chartbox) {
                    chartbox.style.visibility = 'visible';
                });

            });



        } catch (error) {
            console.error('Error:', error);
        }
    }

    function windChart(data1, data2, canvasId, yAxisLabel) {
        if (charts[canvasId]) {
            charts[canvasId].destroy();
        }
        const labels = data2;
        const ctx = document.getElementById(canvasId).getContext('2d');
       
        if (!data1) {
            // Display a message instead of creating a chart
            ctx.font = '16px Arial';
            ctx.fillStyle = 'red';
            ctx.textAlign = 'center'; // Center horizontally
            ctx.textBaseline = 'middle'; // Center vertically
            ctx.fillText('No data available', ctx.canvas.width / 2, ctx.canvas.height / 2 - 10);
            ctx.fillText('Try changing time range', ctx.canvas.width / 2, ctx.canvas.height / 2 + 10);
            return;
        }

        const chartData = {
            labels: labels,
            datasets: [{
                label: 'Wind Direction',
                data: data1,
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                borderWidth: 2,
                fill: false
            }]
        };

        const config = {
            type: 'scatter',
            data: chartData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        type: 'category',
                        labels: ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'],
                        title: {
                            display: true,
                            text: yAxisLabel,
                        }

                    },
                    x: {
                        grid: {
                            display: false,
                        },
                        display: true,
                        type: 'time',
                        time: {
                            unit: 'hour',
                            tooltipFormat: 'MM/dd/yyyy HH:mm',
                            displayFormats: {
                                day: 'MM/dd/yyyy'
                            }
                        },

                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                },
                plugins: {
                    title: {
                        display: true,
                        text: yAxisLabel,
                    },
                    legend: { display: false, },
                    tooltip: {
                        callbacks: {
                            label: function (context) {
                                // Show only the first value

                                return `${context.dataset.label}: ${context.raw}`;
                            },
                            title: function (tooltipItems) {
                                return tooltipItems[0].label;
                            }
                        },
                        mode: 'index',
                        intersect: false
                    },



                }

            }
        };

        charts[canvasId] = new Chart(ctx, config);
    }

    function createChart(canvasId, label, labels, data, yAxisLabel, yMin, yMax, chartType, meandisplay, maxdisplay) {
        if (charts[canvasId]) {
            charts[canvasId].destroy();
            console.log("destroyed chart: ", charts[canvasId])
        }


        const ctx = document.getElementById(canvasId).getContext('2d');
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear any previous content

        if (!data) {
            // Display a message instead of creating a chart
            ctx.font = '16px Arial';
            ctx.fillStyle = 'red';
            ctx.textAlign = 'center'; // Center horizontally
            ctx.textBaseline = 'middle'; // Center vertically
            ctx.fillText('No data available', ctx.canvas.width / 2, ctx.canvas.height / 2 - 10);
            ctx.fillText('Try changing time range', ctx.canvas.width / 2, ctx.canvas.height / 2 + 10);
            return;
        }
        const maxValue = Math.max(...data);
        const meanValue = data.reduce((a, b) => a + b, 0) / data.length;
        charts[canvasId] = new Chart(ctx, {
            type: chartType,
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        grid: {
                            display: false,
                        },
                        display: true,
                        type: 'time',
                        time: {
                            unit: 'hour',
                            tooltipFormat: 'MM/dd/yyyy HH:mm',
                            displayFormats: {
                                day: 'MM/dd/yyyy'
                            }
                        },

                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        grid: {
                            backgroundColor: 'rgba(255,255,125,0.4)',
                        },
                        display: true,
                        min: yMin,
                        max: yMax,
                        title: {
                            display: true,
                            text: yAxisLabel
                        },
                        beginAtZero: false
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: yAxisLabel,
                    },
                    legend: { display: false, },
                    tooltip: {
                        callbacks: {
                            label: function (context) {
                                // Show only the first value

                                return `${context.dataset.label}: ${context.raw}`;
                            },
                            title: function (tooltipItems) {
                                return tooltipItems[0].label;
                            }
                        },
                        mode: 'index',
                        intersect: false
                    },
                    annotation: {
                        annotations: {
                            line1: {
                                display: maxdisplay,
                                type: 'line',
                                yMin: maxValue,
                                yMax: maxValue,
                                borderColor: 'red',
                                borderWidth: 1,
                                legend: {
                                    display: true
                                },
                                label: {
                                    content: `Max Value: ${maxValue}`,
                                    enabled: true,
                                    position: 'end',
                                    backgroundColor: 'rgba(0, 0, 125, 0.4)'
                                }
                            },
                            line2: {
                                display: meandisplay,
                                type: 'line',
                                yMin: meanValue,
                                yMax: meanValue,
                                borderColor: 'blue',
                                borderWidth: 1,
                                label: {
                                    content: `Mean Value: ${meanValue.toFixed(2)}`,
                                    enabled: true,
                                    position: 'end',
                                    backgroundColor: 'rgba(0, 0, 125, 0.4)'
                                }
                            }
                        }
                    },


                }
            }
        });
    }


    function forEachFeatureWU(feature, layer) {
        layer.on('click', function (e) {
            displayWUDetails(feature);
        });
    }



    function loadSmartCitizenData() {
        return fetch('https://environmental-data-ie.spatialdynamicslab.xyz/api/v1/' +
            'smart-citizen/latest-observations.geojson?user_tags=SCOREDUBLINCCLL&system_tags=online')
            .then(function (response) {
                return response.json();

            })
            .then(function (geojsonFeatureCollection) {
                var smartCitizenLayer = L.geoJSON(geojsonFeatureCollection, {
                    onEachFeature: forEachFeature,
                });

                smartCitizenMarkers.addLayer(smartCitizenLayer);
                map.addLayer(smartCitizenMarkers);
                document.getElementById('loading-gif').style.display = 'none';
            })
            .catch(function (error) {
                console.error('Error fetching GeoJSON data:', error);
                // Hide loading GIF
                document.getElementById('loading-gif').style.display = 'none';
            });
    }

    function loadWUData() {

        return fetch('https://environmental-data-ie.spatialdynamicslab.xyz/api/v1/' +
            'weather-underground/pws/latest-observations.geojson')
            .then(function (response) {
                return response.json();

            })
            .then(function (geojsonFeatureCollection) {

                var wuPWSLayer = L.geoJSON(geojsonFeatureCollection, {
                    onEachFeature: forEachFeatureWU,
                });
                wuMarkers.addLayer(wuPWSLayer);
                map.addLayer(wuMarkers);
                // Hide loading GIF
                document.getElementById('loading-gif').style.display = 'none';

            })
            .catch(function (error) {
                console.error('Error fetching Weather Underground GeoJSON data:', error);
                // Hide loading GIF
                document.getElementById('loading-gif').style.display = 'none';
            });
    }



    Promise.all([loadSmartCitizenData(), loadWUData()])
        .then(() => {
            mapBoundsFit(); // Call this function only after both layers are loaded
            document.getElementById('loading-gif').style.display = 'none';
        })
        .catch(error => {
            console.error('Error loading data:', error);
            document.getElementById('loading-gif').style.display = 'none';
        });


    function mapBoundsFit() {
        try {
            var smartCitizenBounds = smartCitizenMarkers.getBounds();
            var wuBounds = wuMarkers.getBounds();

            var combinedBounds = L.latLngBounds([]);

            if (smartCitizenMarkers.getLayers().length > 0) {
                combinedBounds.extend(smartCitizenBounds);
            }
            if (wuMarkers.getLayers().length > 0) {
                combinedBounds.extend(wuBounds);
            }

            console.log("Smart Citizen Bounds:", smartCitizenBounds);
            console.log("WU Bounds:", wuBounds);
            console.log("Combined Bounds:", combinedBounds);

            if (combinedBounds.isValid()) {
                map.fitBounds(combinedBounds);
            } else {
                console.log("Combined bounds are not valid.");
            }
        } catch (error) {
            console.error("Error fitting map bounds:", error);
        }
    }



</script>