<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.0"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-gauge@0.2.1/dist/chartjs-gauge.min.js"></script>

<script>
     // Display loading GIF
     let charts = {};

   var sensor = document.getElementById('sensor');
   var datasensor = document.getElementById('datasensor');
   var chartsarea = document.getElementById('chartscontainer');
   var dropdownarea = document.getElementById('dropdown');
    document.getElementById('loading-gif').style.display = 'block';
    var smartCitizenMarkers = L.markerClusterGroup({
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true
    });
    var wuMarkers = L.markerClusterGroup({
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true
    });

    var baseLayers = {};
    var overlayLayers = {
        "Smart Citizen Devices": smartCitizenMarkers,
        "WU Personal Weather Stations":wuMarkers
    };

    var map = L.map('map').setView([53.3105866, -6.2359141], 13);
    // Load and display tile layer on the map
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; CARTO Â© OpenStreetMap contributors',
        maxZoom: 18
    }).addTo(map);
    

    
    let formattedPreviousDate, formattedCurrentDate;

// Function to format date
function formatDate(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are zero-based
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

function updateDateRange(days) {
    const currentDate = new Date();
    const previousDate = new Date(currentDate);
    previousDate.setDate(currentDate.getDate() - days);

    formattedCurrentDate = formatDate(currentDate);
    formattedPreviousDate = formatDate(previousDate);

    console.log("Current Date: ", formattedCurrentDate);
    console.log("Previous Date: ", formattedPreviousDate);
}

// Initial date range (last 7 days)
updateDateRange(1);



    async function fetchData(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Network response was not ok ' + response.statusText);
            }
            return await response.json();
        }
    // L.control.layers(baseLayers, overlayLayers).addTo(map);
    

    function displayDeviceDetails(feature) {
        
        properties = feature.properties
        var detailsHtml = '<h3 style="color:#004680"><b>' + properties.name + '</b></h3>';
        detailsHtml += '<p>' + properties.description + '<br><br><strong>Last Observation: '
            + properties.last_reading_at +
            '</strong><br><small>Platform provider: ' +
           '<a href="'  + properties.platform_provider.url + '" className="ml-2" target="_blank"> ' +
            properties.platform_provider.name + '</a></small></p>'

        // Horizontal table with one row for CCLL Tags, System Tags, and Owner
        detailsHtml += '<table class="table table-sm table-responsive-sm" >';
        detailsHtml += '<tr>';
        detailsHtml += '<th>CCLL Tags:</th>';
        detailsHtml += '<td>' + properties.user_tags.join(", ") + '</td>';
        detailsHtml += '<th>System Tags:</th>';
        detailsHtml += '<td>' + properties.system_tags.join(", ") + '</td>';
        detailsHtml += '<th>Owner:</th>';
        detailsHtml += '<td>' + properties.owner + '</td>';
        // detailsHtml += '<th>Time series:</th>';
        // detailsHtml += '<td>' + ' <a href="https://dashboard.smartcitizen.me/?id='
        //     + feature.id + '" class="ml-2" target="_blank">Open</a></td>';
        detailsHtml += '</tr>';
        detailsHtml += '</table>';
        // Observations table without 'Added At' column
        detailsHtml += '<table class="table table-sm table-bordered table-hover table-responsive-md">' +
            '<thead class="thead-light">' +
            '<tr><th>Sensor</th><th>Measurement</th><th>Value</th><th>Unit</th></tr></thead><tbody>';
        properties.observations.forEach(function(obs) {
            detailsHtml += '<tr><td>' + obs.sensor_name + '</td><td>' + obs.measurement_name +
                '</td><td>' + obs.value + '</td><td>' + obs.unit + '</td></tr>';
        });
        detailsHtml += '</tbody></table>';

        $('#device-details').html(detailsHtml);

        sensor.style.display = 'none';
        chartsarea.style.display = 'none';
        dropdownarea.style.display = 'none';
        datasensor.style.display='none';
       
    }

     function forEachFeature(feature, layer) {
        layer.on('click', function (e) {
            displayDeviceDetails(feature);
        });
    }

    function displayWUDetails(feature) {
            var properties = feature.properties;
            var observations = properties.observations;
            loadEachWuStationObservation(properties.name);

            var detailsHtml = `
                
            <div class="slider-container">
            <button class="slide-button left" onclick="slideLeft()">&#10094;</button>
               <div class="observations-container">
           
            `;

            for (var key in observations) {
        if (observations.hasOwnProperty(key) && key !== 'id' && key !== 'recorded_at' && key !== 'station_id' && key !== 'station_name') {
            detailsHtml += `
            <a href=#${key} style="border-right: 1px solid #ddd">
                <div class="observation-item">
                    <div class="obsTop">
                    <span class="value">${observations[key].value}</span>
                    <p class="unit">${observations[key].unit}</p>
                    </div>
                    
                   
                    <span class="measurement">${key.replace(/_/g, ' ').toUpperCase()}</span>
                </div>
                </a>
            `;
            console.log(key)
        }
    }
    detailsHtml += `
        	
            </div>
            <button class="slide-button right" onclick="slideRight()">&#10095;</button>
           </div>
           <div class="deviceInfo"> 
            
            <p>Sensor ID: <strong>${properties.name}</strong></p>
            <p><strong>Last observation: </strong>${properties.observations.recorded_at}</p>

            <p><small>Platform provider: <a href="${properties.platform_provider.url}" class="ml-2" target="_blank"> ${properties.platform_provider.name}</a></small></p>    
            
            </div>
        
    `;



            document.getElementById('device-details').innerHTML = detailsHtml;
            const temparature = properties.observations.temp.value;
            const humidity = properties.observations.relative_humidity.value;
            const heatIndex = properties.observations.heat_index.value;
            const pressure = properties.observations.atmospheric_pressure.value
            console.log('heatedIndex', heatIndex)
            // heatIndexMeter(temparature,humidity,heatIndex);
            
         
    }
    function slideLeft() {
    const container = document.querySelector('.observations-container');
    container.scrollBy({ left: -400, behavior: 'smooth' });
}

function slideRight() {
    const container = document.querySelector('.observations-container');
    container.scrollBy({ left: 400, behavior: 'smooth' });
}


   

    var sampleSize = 1;

   // Function to update sampleSize based on screen size
   function updateSampleSize() {
        var isMobile = window.matchMedia("(max-width: 600px)").matches;
        if (document.getElementById('timeRange').value === 'month') {
            sampleSize = isMobile ? 100 : 50;

        }
        else if (document.getElementById('timeRange').value === 'week') {
            sampleSize = isMobile ? 30 : 10;

        }
        else if (document.getElementById('timeRange').value === 'day'){
            sampleSize = isMobile ? 10 : 1;
        }

        
        
        console.log('Sample Size:', sampleSize); // For debugging purposes
    }

        // Update sample size and chart data based on screen size
        function onResize() {
        updateSampleSize();
        if (charts['temp']) {
            loadEachWuStationObservation(sensor.textContent);
        }
    }
       // Add event listener for screen size changes
       window.matchMedia("(max-width: 600px)").addListener(onResize);

updateSampleSize();



  // Handle time range selection
  function onTimeRangeChange() {
        const timeRange = document.getElementById('timeRange').value;
        if (timeRange === 'week') {
            updateDateRange(7);
        } else if (timeRange === 'month') {
            updateDateRange(30);
        }else if (timeRange == 'day'){
            updateDateRange(1);
        }
        updateSampleSize();
        if (sensor.textContent) {
            loadEachWuStationObservation(sensor.textContent);
        }
    }

    async function loadEachWuStationObservation(stationName) {
            try {
                 
                const data = await fetchData(`https://environmental-data-ie.spatialdynamicslab.xyz/api/v1/weather-underground/pws/observations/?station_name=${stationName}&start_date=${formattedPreviousDate}&end_date=${formattedCurrentDate}&limit=10000`);
                
                if (!data.results || data.results.length === 0) {
                    console.log('No data available for this station.');
                    return;
                }
                sensor.style.display = 'inline';
                datasensor.style.display='inline';
                chartsarea.style.display = 'block';
                dropdownarea.style.display = 'inline';
                
                sensor.textContent=stationName;
                const fields = [
                { key: 'temp', label: 'Temperature (Â°C)', unit: 'Â°C', transform: value => value, yMin: null, yMax: null, canvasId: 'temp',chartType:'line' },
                { key: 'atmospheric_pressure', label: 'Atmospheric Pressure (KPa)', unit: 'KPa', transform: value => value / 10, yMin: null, yMax: null, canvasId: 'atmospheric_pressure',chartType:'line' },
                { key: 'heat_index', label: 'Heat Index (Â°C)', unit: 'Â°C', transform: value => value, yMin: null, yMax: null, canvasId: 'heat_index',chartType:'line' },
                { key: 'dew_point', label: 'Dew Point (Â°C)', unit: 'Â°C', transform: value => value, yMin: null, yMax: null, canvasId: 'dew_point',chartType:'line' },
                { key: 'relative_humidity', label: 'Relative Humidity (%)', unit: '%', transform: value => value, yMin: null, yMax: null, canvasId: 'relative_humidity' ,chartType:'line'},
                { key: 'wind_chill', label: 'Wind Chill (Â°C)', unit: 'Â°C', transform: value => value, yMin: null, yMax: null, canvasId: 'wind_chill',chartType:'line' },
                { key: 'solar_radiation', label: 'Solar Radiation (W/mÂ²)', unit: 'W/mÂ²', transform: value => value, yMin: null, yMax: null, canvasId: 'solar_radiation',chartType:'line' },
                { key: 'wind_speed', label: 'Wind Speed (Km/h)', unit: 'km/h', transform: value => value, yMin: null, yMax: null, canvasId: 'wind_speed',chartType:'line' },
                { key: 'wind_gust', label: 'Wind Gust (Km/h)', unit: 'km/h', transform: value => value, yMin: null, yMax: null, canvasId: 'wind_gust' ,chartType:'line'},
                { key: 'wind_direction', label: 'Wind Direction (Deg)', unit: 'Deg', transform: value => value, yMin: 0, yMax: 360, canvasId: 'wind_direction',chartType:'scatter' },
                { key: 'precipitation_rate', label: 'Precipitation Rate (mm/h)', unit: 'mm/h', transform: value => value, yMin: 0, yMax: null, canvasId: 'precipitation_rate' ,chartType:'line'},
                { key: 'precipitation_total', label: 'Precipitation total (mm)', unit: 'mm', transform: value => value, yMin: null, yMax: null, canvasId: 'precipitation_total' ,chartType:'line'},
                { key: 'uv', label: 'UV (UV index)', unit: 'UV index', transform: value => value, yMin: null, yMax: null, canvasId: 'uv' ,chartType:'line'},
                ];

                const labels = data.results.map(observation => new Date(observation.recorded_at)).reverse();
               
                fields.forEach(field => {
                const values = data.results.map(observation => field.transform(observation[field.key].value)).reverse();
                const sampledLabels = labels.filter((_, index) => index % sampleSize === 0);
                const sampledValues = values.filter((_, index) => index %  sampleSize === 0);
                createChart(field.canvasId, field.label, sampledLabels, sampledValues, `${field.label}`, field.yMin, field.yMax, field.chartType);
                });



            } catch (error) {
                console.error('Error:', error);
            }
        }

    
    function createChart(canvasId, label, labels, data, yAxisLabel, yMin, yMax, chartType) {
        if(charts[canvasId]){
            charts[canvasId].destroy();
        }
      const ctx = document.getElementById(canvasId).getContext('2d');
      charts[canvasId] = new Chart(ctx, {
        type: chartType,
        data: {
          labels: labels,
          datasets: [{
            label: label,
            data: data,
            borderColor: 'rgb(75, 192, 192)',
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            borderWidth: 2,
            fill: false,
            tension: 0
          }]
        },
        options: {
          responsive: true,
          
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'hour',
                tooltipFormat: 'MM/dd/yyyy HH:mm',
                displayFormats: {
                  day: 'MM/dd/yyyy'
                }
              },
              
              title: {
                display: true,
                text: 'Time'
              }
            },
            y: {
              min: yMin,
              max: yMax,
              title: {
                display: true,
                text: yAxisLabel
              },
              beginAtZero: false
            }
          },
          plugins: {
            title: {
        display: true,
        text: yAxisLabel,
      },
            legend: {display:false,},
            tooltip: {
                callbacks: {
          label: function(context) {
            // Show only the first value
           
            return `${context.dataset.label}: ${context.raw}`;
          },
          title: function(tooltipItems) {
            return tooltipItems[0].label;
          }
        },
              mode: 'index',
              intersect: false
            },
        
          }
        }
      });
    }


    function forEachFeatureWU(feature, layer) {
        layer.on('click', function (e) {
            displayWUDetails(feature);
        });
    }



    function loadSmartCitizenData() {
        return fetch('https://environmental-data-ie.spatialdynamicslab.xyz/api/v1/' +
        'smart-citizen/latest-observations.geojson?user_tags=SCOREDUBLINCCLL&system_tags=online')
        .then(function(response) {
            return response.json();
            
        })
        .then(function(geojsonFeatureCollection) {
            var smartCitizenLayer = L.geoJSON(geojsonFeatureCollection, {
                onEachFeature: forEachFeature,
            });

            smartCitizenMarkers.addLayer(smartCitizenLayer);
            map.addLayer(smartCitizenMarkers);
            document.getElementById('loading-gif').style.display = 'none';
        })
        .catch(function(error) {
            console.error('Error fetching GeoJSON data:', error);
            // Hide loading GIF
            document.getElementById('loading-gif').style.display = 'none';
        });
    }

    function loadWUData() {
        
        return fetch('https://environmental-data-ie.spatialdynamicslab.xyz/api/v1/' +
        'weather-underground/pws/latest-observations.geojson')
        .then(function(response) {
            return response.json();
            
        })
        .then(function(geojsonFeatureCollection) {
             
            var wuPWSLayer = L.geoJSON(geojsonFeatureCollection, {
                onEachFeature: forEachFeatureWU,
            });
            wuMarkers.addLayer(wuPWSLayer);
            map.addLayer(wuMarkers);
            // Hide loading GIF
            document.getElementById('loading-gif').style.display = 'none';
          
        })
        .catch(function(error) {
            console.error('Error fetching Weather Underground GeoJSON data:', error);
            // Hide loading GIF
            document.getElementById('loading-gif').style.display = 'none';
        });
    }

   

    Promise.all([loadSmartCitizenData(), loadWUData()])
        .then(() => {
            mapBoundsFit(); // Call this function only after both layers are loaded
            document.getElementById('loading-gif').style.display = 'none';
        })
        .catch(error => {
            console.error('Error loading data:', error);
            document.getElementById('loading-gif').style.display = 'none';
        });


   function mapBoundsFit () {
       try {
           var smartCitizenBounds = smartCitizenMarkers.getBounds();
           var wuBounds = wuMarkers.getBounds();

            var combinedBounds = L.latLngBounds([]);

            if (smartCitizenMarkers.getLayers().length > 0) {
                combinedBounds.extend(smartCitizenBounds);
            }
            if (wuMarkers.getLayers().length > 0) {
                combinedBounds.extend(wuBounds);
            }

            console.log("Smart Citizen Bounds:", smartCitizenBounds);
            console.log("WU Bounds:", wuBounds);
            console.log("Combined Bounds:", combinedBounds);

            if (combinedBounds.isValid()) {
                map.fitBounds(combinedBounds);
            } else {
                console.log("Combined bounds are not valid.");
            }
        } catch (error) {
            console.error("Error fitting map bounds:", error);
        }
   }



</script>