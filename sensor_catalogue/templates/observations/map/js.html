<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.0"></script>


<script>
    // Display loading GIF
    let charts = {};
    // let backToTopBtn = document.getElementById("backToTopBtn");
    const sensor = document.getElementById('sensor');
    const datasensor = document.getElementById('datasensor');
    const chartsarea = document.getElementById('chartscontainer');
    const smartChartArea = document.getElementById('smartChartContainer');
    const dropdownarea = document.getElementById('dropdown');
    const cLoading = document.getElementById('chart-loading');
    const chartboxes = document.querySelectorAll('.chartbox');
    const noData = document.getElementById('noData');
    let dda = "";

    // socials
    document.getElementById('facebook-btn').addEventListener('click', function() {
    const url = window.location.href;
    const facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}`;
    window.open(facebookUrl, '_blank');
});

document.getElementById('twitter-btn').addEventListener('click', function() {
    const url = window.location.href;
    const text = encodeURIComponent('Check out this sensor data!');
    const twitterUrl = `https://twitter.com/intent/tweet?url=${encodeURIComponent(url)}&text=${text}`;
    window.open(twitterUrl, '_blank');
});

// document.getElementById('instagram-btn').addEventListener('click', function() {
//     // Note: Instagram doesn't support direct sharing of URLs via a web link like Facebook and Twitter.
//     // This button can provide instructions or open Instagram if installed.
//     alert('Instagram does not support direct URL sharing. Please share the link manually.');
// });


    const cardinalPoints = [
        { label: "N", min: 348.75, max: 360 },
        { label: "N", min: 0, max: 11.25 },
        { label: "NNE", min: 11.25, max: 33.75 },
        { label: "NE", min: 33.75, max: 56.25 },
        { label: "ENE", min: 56.25, max: 78.75 },
        { label: "E", min: 78.75, max: 101.25 },
        { label: "ESE", min: 101.25, max: 123.75 },
        { label: "SE", min: 123.75, max: 146.25 },
        { label: "SSE", min: 146.25, max: 168.75 },
        { label: "S", min: 168.75, max: 191.25 },
        { label: "SSW", min: 191.25, max: 213.75 },
        { label: "SW", min: 213.75, max: 236.25 },
        { label: "WSW", min: 236.25, max: 258.75 },
        { label: "W", min: 258.75, max: 281.25 },
        { label: "WNW", min: 281.25, max: 303.75 },
        { label: "NW", min: 303.75, max: 326.25 },
        { label: "NNW", min: 326.25, max: 348.75 }
    ];


    document.getElementById('loading-gif').style.display = 'block';
    var smartCitizenMarkers = L.markerClusterGroup({
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true
    });
    var wuMarkers = L.markerClusterGroup({
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true
    });

    var baseLayers = {};
    var overlayLayers = {
        "Smart Citizen Devices": smartCitizenMarkers,
        "WU Personal Weather Stations": wuMarkers
    };

    var map = L.map('map').setView([53.3105866, -6.2359141], 13);
    // Load and display tile layer on the map
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; CARTO Â© OpenStreetMap contributors',
        maxZoom: 18
    }).addTo(map);

    // window.onscroll = function () {
    //     scrollFunction();
    // };

    function getCardinalDirection(degree) {
        for (let i = 0; i < cardinalPoints.length; i++) {
            const point = cardinalPoints[i];
            if (degree >= point.min && degree < point.max) {
                return point.label;
            }
        }
        return "Invalid degree";
    }

    // function scrollFunction() {
    //     if (document.body.scrollTop > 50 || document.documentElement.scrollTop > 50) {
    //         backToTopBtn.style.display = "block";
    //     } else {
    //         backToTopBtn.style.display = "none";
    //     }
    // }
    // When the user clicks on the button, scroll to the top of the document
    // backToTopBtn.addEventListener('click', function () {
    //     document.body.scrollTop = 0; // For Safari
    //     document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    // });


    let formattedPreviousDate, formattedCurrentDate;

    // Function to format date
    function formatDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are zero-based
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    function updateDateRange(days) {
        const currentDate = new Date();
        const previousDate = new Date(currentDate);
        previousDate.setDate(currentDate.getDate() - days);

        formattedCurrentDate = formatDate(currentDate);
        formattedPreviousDate = formatDate(previousDate);


    }

    // Initial date range (last 7 days)
    updateDateRange(1);



    async function fetchData(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Network response was not ok ' + response.statusText);
        }
        return await response.json();
    }
    // L.control.layers(baseLayers, overlayLayers).addTo(map);




    function getUrlParams() {
    let params = {};
    let url = window.location.href;
    let parser = document.createElement('a');
    parser.href = url;
    let query = parser.search.substring(1);
    let vars = query.split('&');
    vars.forEach(function(v) {
        let pair = v.split('=');
        params[pair[0]] = decodeURIComponent(pair[1]);
    });
    return params;
}

function zoomToSensorFromUrl() {
    let urlParts = window.location.pathname.split('/');
    let sensorId = urlParts[urlParts.length - 2];
    
   
    // TODO:  use sensorId to zoom to the sensor
    function zoomToSensor(markers) {
        markers.eachLayer(function(layer) {
            if (layer.feature.id == sensorId) {
                map.setView(layer.getLatLng(), 15);  // Zoom level 15 can be adjusted
                layer.openPopup();
            }
        });
    }

    // Search in Smart Citizen Markers
    zoomToSensor(smartCitizenMarkers);

    // Search in WU Markers
    zoomToSensor(wuMarkers);

}










    // smart citizen data display
    let senId = null;
    function displayDeviceDetails(feature) {
        chartsarea.style.display = 'none';
        dda = "";
        dda = "wu";
        var properties = feature.properties
        sensor.textContent = properties.name;

        let sensorId = feature.id;
  let sensorUrl = `${window.location.origin}/map/${sensorId}/`;
    history.pushState(null, null, sensorUrl);



        var detailsHtml = `
        <div  style=" display: flex;
    justify-content: space-evenly;
    font-size: 10px;
    font-weight: bolder;
    background-color: cadetblue;
    max-width: 80%;
    margin: 0 auto;
    /* align-items: center; */
    text-align: center;
    border-radius: 10px 10px 10px 10px; ">  

                    <p style="   
                     margin-top: 4px;
                    margin-bottom: 0px;
                    color: white;">CCLL Tags: ${properties.user_tags.join(", ")}</p>

                   

                    <p style="   
                     margin-top: 4px;
                    margin-bottom: 0px;
                    color: white; "
                    >System Tags: ${properties.system_tags.join(", ")}</p>

                   

                    <p style="   
                     margin-top: 4px;
                    margin-bottom: 0px;
                    color: white; "
                    >Owner: ${properties.owner}</p>

                  
        </div>
        <div class="slider-container">
            <button class="slide-button left" onclick="slideLeft()">&#10094;</button>
            <div class="observations-container">
                
    `;
        properties.observations.forEach(function (obs) {
            detailsHtml += `
            <a href=#${obs.sensor_name}  onclick="updateChart(${obs.sensor_id})" style="border-right: 1px solid #ddd">
                <div class="observation-item">
                    <div class="obsTop">
                        <span class="value">${obs.value}</span>
                        <p class="unit">${obs.unit}</p>
                    </div>
                    <span class="measurement">${obs.measurement_name}</span>
                </div>
            </a>
        `;
        });
        detailsHtml += `
            </div>
            <button class="slide-button right" onclick="slideRight()">&#10095;</button>
        </div>
         
                
                   
               
          
        <div class="deviceInfo">
            <p style="border:2px solid #5f9ea0; padding:5px; border-radius: 20px; font-size:10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    background-color: rgb(255, 255, 255); " ><strong>${properties.name}: </strong>${properties.description}</p>
           
            <p style="border:2px solid #5f9ea0; padding:5px; border-radius: 20px; font-size:10px;     box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    background-color: rgb(255, 255, 255); " ><strong>Last Observation: </strong>${properties.last_reading_at}</p>
            <p style="border:2px solid #5f9ea0; padding:5px; border-radius: 20px; font-size:10px;     box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    background-color: rgb(255, 255, 255); " ><small>Platform provider: <a href="${properties.platform_provider.url}" class="ml-2" target="_blank"> ${properties.platform_provider.name}</a></small></p>
           
        </div>
        <p style="text-align:center"   ><small>Click on an observation to view the chart</small></p>
      
    `;

        document.getElementById('device-details').innerHTML = detailsHtml;

        dropdownarea.style.display = 'block';
        datasensor.style.display = 'none';

    }

    function updateChart(sId) {
        senId = sId;
        chartsarea.style.display = 'none';
        smartChartArea.style.display = 'block';
        loadEachSmartStationObservation(sensor.textContent, sId);
    }
    function forEachFeature(feature, layer) {
        layer.on('click', function (e) {
            displayDeviceDetails(feature);
        });
    }

    let keywu = null;
    function showChart(key) {
        keywu = key;
       console.log("Key:", key);

       loadEachWuStationObservation(sensor.textContent,key);
    }






    function displayWUDetails(feature) {
        dda = "";
        dda = "sc";
        var properties = feature.properties;
        var observations = properties.observations;
        x = feature
        console.log("User tags:", x);
        smartChartArea.style.display = 'none';
        
        chartsarea.style.display = 'none';
        sensor.textContent = properties.name;

        let sensorId = feature.id;
   
    
    let sensorUrl = `${window.location.origin}/map/${sensorId}/`;
    history.pushState(null, null, sensorUrl);



        var detailsHtml = `

         <div  style=" display: flex;
    justify-content: space-evenly;
    font-size: 10px;
    font-weight: bolder;
    background-color: cadetblue;
    max-width: 80%;
    margin: 0 auto;
    /* align-items: center; */
    text-align: center;
    border-radius: 10px 10px 10px 10px; ">  

                    <p style="   
                     margin-top: 4px;
                    margin-bottom: 0px;
                    color: white;">CCLL Tags:  ${properties.user_tags}</p>

                   

                    <p style="   
                     margin-top: 4px;
                    margin-bottom: 0px;
                    color: white; "
                    >System Tags:  ${properties.system_tags}</p>

                   

                    <p style="   
                     margin-top: 4px;
                    margin-bottom: 0px;
                    color: white; "
                    >Owner: SCORE</p>
                </div>
                
            <div class="slider-container">
            <button class="slide-button left" onclick="slideLeft()">&#10094;</button>
               <div class="observations-container">
           
            `;

        for (var key in observations) {
            if (observations.hasOwnProperty(key) && key !== 'id' && key !== 'recorded_at' && key !== 'station_id' && key !== 'station_name') {
                detailsHtml += `
            <a href=#${key}  onclick="showChart('${key}')" style="border-right: 1px solid #ddd">
                <div class="observation-item">
                    <div class="obsTop">
                    <span class="value">${observations[key].value}</span>
                    <p class="unit">${observations[key].unit}</p>
                    </div>
                    
                   
                    <span class="measurement">${key.replace(/_/g, ' ').toUpperCase()}</span>
                </div>
                </a>
            `;

            }
        }
        detailsHtml += `
        	
            </div>
            <button class="slide-button right" onclick="slideRight()">&#10095;</button>
           </div>
           <div class="deviceInfo"> 
            
            <p style="border:2px solid #5f9ea0; padding:5px; border-radius: 20px; font-size:10px;      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    background-color: rgb(255, 255, 255);  ">Sensor ID: <strong>${properties.name}</strong></p>
            <p style="border:2px solid #5f9ea0; padding:5px; border-radius: 20px; font-size:10px;     box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    background-color: rgb(255, 255, 255); " ><strong>Last observation: </strong>${properties.observations.recorded_at}</p>

            <p style="border:2px solid #5f9ea0; padding:5px; border-radius: 20px; font-size:10px;     box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    background-color: rgb(255, 255, 255); "  ><small>Platform provider: <a href="${properties.platform_provider.url}" class="ml-2" target="_blank"> ${properties.platform_provider.name}</a></small></p>    
            
            </div>
                    <p style="text-align:center"   ><small>Click on an observation to view the chart</small></p>

        
    `;



        document.getElementById('device-details').innerHTML = detailsHtml;

        // heatIndexMeter(temparature,humidity,heatIndex);


    }
  
    function slideLeft() {
        const container = document.querySelector('.observations-container');
        container.scrollBy({ left: -200, behavior: 'smooth' });
        
    }
    

    function slideRight() {
        const container = document.querySelector('.observations-container');
        container.scrollBy({ left: 200, behavior: 'smooth' });
    }




    var sampleSize = 1;

    // Function to update sampleSize based on screen size
    function updateSampleSize() {
        var isMobile = window.matchMedia("(max-width: 600px)").matches;
        if (document.getElementById('timeRange').value === 'month') {
            sampleSize = isMobile ? 100 : 50;

        }
        else if (document.getElementById('timeRange').value === 'week') {
            sampleSize = isMobile ? 30 : 10;

        }
        else if (document.getElementById('timeRange').value === 'day') {
            sampleSize = isMobile ? 10 : 5;
        }

    }

    // Update sample size and chart data based on screen size
    function onResize() {
        updateSampleSize();
        if (charts['temp']) {
            console.log("")
            showChart(keywu);
        
        } else if (charts['smart-chart']) {
            updateChart(senId);
        }
    }
    // Add event listener for screen size changes
    window.matchMedia("(max-width: 600px)").addListener(onResize);

    updateSampleSize();



    // Handle time range selection
    function onTimeRangeChange() {
        const timeRange = document.getElementById('timeRange').value;
        console.log("Time range selected:", timeRange);
        if (timeRange === 'week') {
            updateDateRange(7);
        } else if (timeRange === 'month') {
            updateDateRange(30);
        } else if (timeRange == 'day') {
            updateDateRange(1);
        }
        updateSampleSize();
        if (sensor.textContent) {

            if (dda == "wu" && senId != null) {
                console.log("senid:", senId)
                
                updateChart(senId);


            } else if (dda == "sc" && keywu != null) {
                console.log("keyu", keywu)
                showChart(keywu);
                

            }


        }
    }


    async function loadEachWuStationObservation(stationName, chartobsType) {
        try {
            cLoading.style.display = 'unset';
            noData.style.display = 'none';
            const data = await fetchData(`https://environmental-data.spatialdynamics.cloud/api/v1/weather-underground/pws/observations/?station_name=${stationName}&start_date=${formattedPreviousDate}&end_date=${formattedCurrentDate}&limit=10000`);

            if (!data.results || data.results.length === 0) {
                console.log('No data available for this station.');
                cLoading.style.display = 'none';
                noData.style.display = 'block';
                return;

            }
            sensor.style.display = 'inline';
            datasensor.style.display = 'inline';
            chartsarea.style.display = 'block';
            dropdownarea.style.display = 'block';


            const fields = [
                { key: 'temp', label: 'Temperature (Â°C)', unit: 'Â°C', transform: value => value, yMin: null, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'atmospheric_pressure', label: 'Atmospheric Pressure (KPa)', unit: 'KPa', transform: value => value / 10, yMin: null, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'heat_index', label: 'Heat Index (Â°C)', unit: 'Â°C', transform: value => value, yMin: null, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'dew_point', label: 'Dew Point (Â°C)', unit: 'Â°C', transform: value => value, yMin: null, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'relative_humidity', label: 'Relative Humidity (%)', unit: '%', transform: value => value, yMin: null, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'wind_chill', label: 'Wind Chill (Â°C)', unit: 'Â°C', transform: value => value, yMin: null, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'solar_radiation', label: 'Solar Radiation (W/mÂ²)', unit: 'W/mÂ²', transform: value => value, yMin: null, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'wind_speed', label: 'Wind Speed (Km/h)', unit: 'km/h', transform: value => value, yMin: null, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'wind_gust', label: 'Wind Gust (Km/h)', unit: 'km/h', transform: value => value, yMin: null, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'wind_direction', label: 'Wind Direction (Deg)', unit: 'Deg', transform: value => value, yMin: 0, yMax: 360, canvasId: 'temp', chartType: 'line' },
                { key: 'precipitation_rate', label: 'Precipitation Rate (mm/h)', unit: 'mm/h', transform: value => value, yMin: 0, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'precipitation_total', label: 'Precipitation total (mm)', unit: 'mm', transform: value => value, yMin: null, yMax: null, canvasId: 'temp', chartType: 'line' },
                { key: 'uv', label: 'UV (UV index)', unit: 'UV index', transform: value => value, yMin: null, yMax: null, canvasId:'temp', chartType: 'line' },
            ];
            const labels = data.results.map(observation => new Date(observation.recorded_at)).reverse();

            fields.forEach(field => {
                // only show chart for obstype selected
                if (chartobsType && field.key == chartobsType) {
                    
                
                const hasValidData = data.results.some(observation => observation[field.key] !== undefined && observation[field.key] !== null);
                const values = hasValidData
                    ? data.results.map(observation => observation[field.key] !== undefined && observation[field.key] !== null ? field.transform(observation[field.key].value) : null).reverse()
                    : null;

                const sampledLabels = labels.filter((_, index) => index % sampleSize === 0);
                const sampledValues = values ? values.filter((_, index) => index % sampleSize === 0) : null;
                cLoading.style.display = 'none';
                let meandisplay = true;
                let maxdisplay = true;
                let directionLabels;
                if (field.unit == 'Deg') {
                    meandisplay = false;
                    maxdisplay = false;
                    if (sampledValues) {


                        const validSampledValues = sampledValues.filter(value => value !== null && value !== undefined);
                        directionLabels = validSampledValues.map(value => getCardinalDirection(value));

                        const directionCounts = {};
                        directionLabels.forEach(direction => {
                            directionCounts[direction] = (directionCounts[direction] || 0) + 1;
                        });
                        const windDirectionData = Object.keys(directionCounts).map(direction => ({
                            direction,
                            frequency: directionCounts[direction]
                        }));



                    }
                    windChart(directionLabels, sampledLabels, field.canvasId, `${field.label}`)


                } else {
                    createChart(field.canvasId, field.label, sampledLabels, sampledValues, `${field.label}`, field.yMin, field.yMax, field.chartType, meandisplay, maxdisplay);
                }

                for (let i = 0; i < chartboxes.length; i++) {
                    chartboxes[i].style.display = 'block';
                }
                

            }else{
                return;
            }
            });



        } catch (error) {
            console.error('Error:', error);
        }
    }



    async function loadEachSmartStationObservation(deviceName, sId) {
        try {
            cLoading.style.display = 'unset';
            noData.style.display = 'none';

            const url = `https://environmental-data.spatialdynamics.cloud/api/v1/smart-citizen/observations/?device_name=${deviceName}&sensor_id=${sId}&start_date=${formattedPreviousDate}&end_date=${formattedCurrentDate}&limit=10000`;
            console.log("Fetching data from URL:", url);
            const data = await fetchData(url);


            if (!data.results || data.results.length === 0) {
                console.log('No data available for this station.');
                cLoading.style.display = 'none';
                noData.style.display = 'block';
                return;
            }


            const measurementName = data.results[0].measurement_name;
            const sensorName = data.results[0].sensor_name;



            const labels = data.results.map(observation => new Date(observation.recorded_at)).reverse();
            const values = data.results.map(observation => observation.value).reverse();

            // Filter null values
            const filteredLabels = labels.filter((_, index) => values[index] !== null);
            const filteredValues = values.filter(value => value !== null);

            // Downsample data if necessary
            const maxPoints = 100; // Maximum number of points to display in the chart
            const step = Math.ceil(filteredValues.length / maxPoints);
            const sampledLabels = filteredLabels.filter((_, index) => index % step === 0);
            const sampledValues = filteredValues.filter((_, index) => index % step === 0);
            createChart('smart-chart', `${sensorName}`, sampledLabels, sampledValues, measurementName, null, null, 'line', true, true);
            //smartChart(sampledLabels, sampledValues);
            cLoading.style.display = 'none';
        } catch (error) {
            console.error('Error:', error);
        }
    }


    function windChart(data1, data2, canvasId, yAxisLabel) {
        if (charts[canvasId]) {
            charts[canvasId].destroy();
        }
        const labels = data2;
        const ctx = document.getElementById(canvasId).getContext('2d');

        if (!data1) {
            // Display a message instead of creating a chart
            ctx.font = '16px Arial';
            ctx.fillStyle = 'red';
            ctx.textAlign = 'center'; // Center horizontally
            ctx.textBaseline = 'middle'; // Center vertically
            ctx.fillText('No data available', ctx.canvas.width / 2, ctx.canvas.height / 2 - 10);
            ctx.fillText('Try changing time range', ctx.canvas.width / 2, ctx.canvas.height / 2 + 10);
            return;
        }

        const chartData = {
            labels: labels,
            datasets: [{
                label: 'Wind Direction',
                data: data1,
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                borderWidth: 2,
                fill: false
            }]
        };

        const config = {
            type: 'scatter',
            data: chartData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        type: 'category',
                        labels: ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'],
                        title: {
                            display: true,
                            text: yAxisLabel,
                        }

                    },
                    x: {
                        grid: {
                            display: false,
                        },
                        display: true,
                        type: 'time',
                        time: {
                            unit: 'hour',
                            tooltipFormat: 'MM/dd/yyyy HH:mm',
                            displayFormats: {
                                day: 'MM/dd/yyyy'
                            }
                        },

                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                },
                plugins: {
                    title: {
                        display: true,
                        text: yAxisLabel,
                    },
                    legend: { display: false, },
                    tooltip: {
                        callbacks: {
                            label: function (context) {
                                // Show only the first value

                                return `${context.dataset.label}: ${context.raw}`;
                            },
                            title: function (tooltipItems) {
                                return tooltipItems[0].label;
                            }
                        },
                        mode: 'index',
                        intersect: false
                    },



                }

            }
        };

        charts[canvasId] = new Chart(ctx, config);
    }

    function createChart(canvasId, label, labels, data, yAxisLabel, yMin, yMax, chartType, meandisplay, maxdisplay) {

        if (charts[canvasId]) {
            charts[canvasId].destroy();
            console.log("destroyed chart: ", charts[canvasId])
        }


        const ctx = document.getElementById(canvasId).getContext('2d');
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear any previous content

        if (!data) {
            // Display a message instead of creating a chart
            ctx.font = '16px Arial';
            ctx.fillStyle = 'red';
            ctx.textAlign = 'center'; // Center horizontally
            ctx.textBaseline = 'middle'; // Center vertically
            ctx.fillText('No data available', ctx.canvas.width / 2, ctx.canvas.height / 2 - 10);
            ctx.fillText('Try changing time range', ctx.canvas.width / 2, ctx.canvas.height / 2 + 10);
            return;
        }
        const maxValue = Math.max(...data);
        const meanValue = data.reduce((a, b) => a + b, 0) / data.length;
        charts[canvasId] = new Chart(ctx, {
            type: chartType,
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        grid: {
                            display: false,
                        },
                        display: true,
                        type: 'time',
                        time: {
                            unit: 'hour',
                            tooltipFormat: 'MM/dd/yyyy HH:mm',
                            displayFormats: {
                                day: 'MM/dd/yyyy'
                            }
                        },

                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        grid: {
                            backgroundColor: 'rgba(255,255,125,0.4)',
                        },
                        display: true,
                        min: yMin,
                        max: yMax,
                        title: {
                            display: true,
                            text: yAxisLabel
                        },
                        beginAtZero: false
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: label,
                    },
                    legend: { display: false, },
                    tooltip: {
                        callbacks: {
                            label: function (context) {
                                // Show only the first value

                                return `${context.dataset.label}: ${context.raw}`;
                            },
                            title: function (tooltipItems) {
                                return tooltipItems[0].label;
                            }
                        },
                        mode: 'index',
                        intersect: false
                    },
                    annotation: {
                        annotations: {
                            line1: {
                                display: maxdisplay,
                                type: 'line',
                                yMin: maxValue,
                                yMax: maxValue,
                                borderColor: 'red',
                                borderWidth: 1,
                                legend: {
                                    display: true
                                },
                                label: {
                                    content: `Max Value: ${maxValue}`,
                                    enabled: true,
                                    position: 'end',
                                    backgroundColor: 'rgba(0, 0, 125, 0.4)'
                                }
                            },
                            line2: {
                                display: meandisplay,
                                type: 'line',
                                yMin: meanValue,
                                yMax: meanValue,
                                borderColor: 'blue',
                                borderWidth: 1,
                                label: {
                                    content: `Mean Value: ${meanValue.toFixed(2)}`,
                                    enabled: true,
                                    position: 'end',
                                    backgroundColor: 'rgba(0, 0, 125, 0.4)'
                                }
                            }
                        }
                    },


                }
            }
        });
    }


    function forEachFeatureWU(feature, layer) {
        layer.on('click', function (e) {
            displayWUDetails(feature);
        });
    }

    function createDefaultIcon(color, size, x) {
        if (x === 'smart') {
            return L.divIcon({
                className: 'custom-circle-icon',
                html: `<div style="
                background-color: ${color};
                width: ${size}px;
                height: ${size}px;
                align-content:center;
                text-align:center;
                border-radius: 50%;
                border: 2px solid rgba(63, 245, 39, 0.75);
                ">SC</div>`,
                iconSize: [size, size],
                iconAnchor: [size / 2, size / 2]
            });

        }
        return L.divIcon({
            className: 'custom-circle-icon',
            html: `<div style="
                background-color: ${color};
                width: ${size}px;
                height: ${size}px;
                align-content:center;
                text-align:center;
                border-radius: 50%;
                border: 2px solid rgba(63, 245, 39, 0.75);
                ">WS</div>`,
            iconSize: [size, size],
            iconAnchor: [size / 2, size / 2]
        });

    }
    function createClickedIcon(size, x) {
        if (x === 'smart') {
            return L.divIcon({
                html: `<div style="
                background-color:rgba(243, 0, 32, 0.59) ;
                width: 30px;
                height: 30px;
                align-content:center;
                text-align:center;
                border-radius: 50%;
                border: 2px solid rgba(243, 0, 32, 0.89);
                ">SC</div>`,
                iconSize: [size, size],
                iconAnchor: [size / 2, size / 2]
                ,
                className: '',
            });


        }
        return L.divIcon({
            html: `<div style="
                background-color:rgba(243, 0, 32, 0.59) ;
                width: 30px;
                height: 30px;
                align-content:center;
                text-align:center;
                border-radius: 50%;
                border: 2px solid rgba(243, 0, 32, 0.89);
                ">WS</div>`,
            iconSize: [size, size],
            iconAnchor: [size / 2, size / 2]
            ,
            className: '',
        });

    }

    var selectedMarker = null;
    var selectedMarkerType = null;

    function loadSmartCitizenData() {
        return fetch('https://environmental-data.spatialdynamics.cloud/api/v1/' +
            'smart-citizen/sck-devices.geojson?user_tags=SCORE&system_tags=online')
            .then(function (response) {
                return response.json();
            })
            .then(function (geojsonFeatureCollection) {
                var smartCitizenLayer = L.geoJSON(geojsonFeatureCollection.results, {
                    pointToLayer: function (feature, latlng) {
                        var marker = L.marker(latlng, {
                            icon: createDefaultIcon('rgba(63, 245, 39, 0.48)', 30, 'smart')
                        });
                        marker.on('click', function () {
                            if (selectedMarker) {
                                selectedMarker.setIcon(createDefaultIcon('rgba(63, 245, 39, 0.48)', 30, selectedMarkerType));
                
                                map.setView(marker.getLatLng(), 20);

                            }
                            marker.setIcon(createClickedIcon(30, 'smart'));
                            selectedMarker = marker;
                            selectedMarkerType = 'smart';
                            
                            map.setView(marker.getLatLng(), 20);

                            const tp =  document.getElementById('device-details');
             
                            window.scrollTo({

                                top: 200,
                                behavior: 'smooth' // Smooth scroll

                            })
                            
                        });
                        return marker;
                    },
                    onEachFeature: forEachFeature,
                });

                smartCitizenMarkers.addLayer(smartCitizenLayer);
                map.addLayer(smartCitizenMarkers);
          
            })
            .catch(function (error) {
                console.error('Error fetching GeoJSON data:', error);
                // Hide loading GIF
                document.getElementById('loading-gif').style.display = 'none';
            });
    }


    function loadWUData() {

        return fetch('https://environmental-data.spatialdynamics.cloud/api/v1/' +
            'weather-underground/pws-stations.geojson?system_tags=online')
            .then(function (response) {
                return response.json();

            })
            .then(function (geojsonFeatureCollection) {

                var wuPWSLayer = L.geoJSON(geojsonFeatureCollection.results, {
                    pointToLayer: function (feature, latlng) {
                        var marker = L.marker(latlng, {
                            icon: createDefaultIcon('rgba(63, 245, 39, 0.48)', 30, 'wu')
                        });
                        marker.on('click', function () {
                            if (selectedMarker) {
                                selectedMarker.setIcon(createDefaultIcon('rgba(63, 245, 39, 0.48)', 30, selectedMarkerType));
                                map.setView(marker.getLatLng(), 20);

                            }
                            marker.setIcon(createClickedIcon(30, 'wu'));
                            map.setView(marker.getLatLng(), 20);
                            selectedMarker = marker;
                            selectedMarkerType = 'wu';
                            const tp =  document.getElementById('device-details');
                     
                            window.scrollTo({

                                top: 200,
                                behavior: 'smooth' // Smooth scroll

                            })
                        });
                        return marker;
                    },
                    onEachFeature: forEachFeatureWU,
                });
                wuMarkers.addLayer(wuPWSLayer);
                map.addLayer(wuMarkers);
                // Hide loading GIF
                
            })
            .catch(function (error) {
                console.error('Error fetching Weather Underground GeoJSON data:', error);
                // Hide loading GIF
                document.getElementById('loading-gif').style.display = 'none';
            });
    }



    Promise.all([loadSmartCitizenData(), loadWUData()])
        .then(() => {
            mapBoundsFit(); // Call this function only after both layers are loaded
         
            zoomToSensorFromUrl();
            document.getElementById('loading-gif').style.display = 'none';
        })
        .catch(error => {
            console.error('Error loading data:', error);
            document.getElementById('loading-gif').style.display = 'none';
        });


    function mapBoundsFit() {
        try {
            var smartCitizenBounds = smartCitizenMarkers.getBounds();
            var wuBounds = wuMarkers.getBounds();

            var combinedBounds = L.latLngBounds([]);

            if (smartCitizenMarkers.getLayers().length > 0) {
                combinedBounds.extend(smartCitizenBounds);
            }
            if (wuMarkers.getLayers().length > 0) {
                combinedBounds.extend(wuBounds);
            }

            console.log("Smart Citizen Bounds:", smartCitizenBounds);
            console.log("WU Bounds:", wuBounds);
            console.log("Combined Bounds:", combinedBounds);

            if (combinedBounds.isValid()) {
                map.fitBounds(combinedBounds);
            } else {
                console.log("Combined bounds are not valid.");
            }
        } catch (error) {
            console.error("Error fitting map bounds:", error);
        }
    }



</script>